# -*- coding: utf-8 -*-
"""projeto_conjunção

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_jz3M8J9zQtUuwR3SRJDGwW10K7Brvwr
"""

# Autor:Thomas Inacio da Silva
# Detecção e Classificação de Alto Risco de Conjunção em LEO por meio de SVM, RobustScaler e TLEs
# Instalação da biblioteca requirements.txt
import pandas as pd
import numpy as np
import requests
import getpass
from datetime import timedelta, datetime
from skyfield.api import EarthSatellite, load, utc
from sklearn import svm
from sklearn.preprocessing import RobustScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, classification_report
from imblearn.over_sampling import SMOTE
import sys
import time
import os

# --- CONFIGURAÇÃO GLOBAL ---
ts = load.timescale()
RANDOM_STATE = 42
TEMPO_ANALISE_HORAS = 24  # Buscar D_min em 24 horas
RESOLUCAO_MINUTOS = 10
LIMIAR_CONSERVADOR = 0.01 # Limiar ajustado para mitigar o FN

# --- FUNÇÕES DE UTILIDADE (Skyfield) ---

def calcular_melhor_aproximacao(l1_a: str, l2_a: str, l1_b: str, l2_b: str, t_base_dt: datetime):
    """ Propaga a órbita e calcula D_min, V_rel e T_min (tempo até D_min) """
    t_base = ts.utc(t_base_dt)
    try:
        sat_a = EarthSatellite(l1_a, l2_a, 'SAT_A', ts)
        sat_b = EarthSatellite(l1_b, l2_b, 'SAT_B', ts)
    except Exception:
        return np.nan, np.nan, np.nan, None

    # Define o intervalo de tempo para a propagação
    tempos_dt = [t_base_dt + timedelta(minutes=m)
                 for m in range(0, TEMPO_ANALISE_HORAS * 60, RESOLUCAO_MINUTOS)]
    t_propagacao = ts.utc(tempos_dt)

    # Propagação e cálculo de D_min
    a, b = sat_a.at(t_propagacao), sat_b.at(t_propagacao)
    dist = np.linalg.norm(a.position.km - b.position.km, axis=0)
    i = np.argmin(dist)
    d_min = dist[i]

    # Cálculo de V_rel e T_min
    v_a, v_b = a.velocity.km_per_s, b.velocity.km_per_s
    v_rel = np.linalg.norm(v_a[:, i] - v_b[:, i])
    t_min = (t_propagacao[i].tt - t_base.tt) * 1440

    return d_min, v_rel, t_min, t_propagacao[i]


# --- 1. TREINAMENTO INICIAL ---

def treinar_modelo_inicial():
    """Treina o modelo SVM e o RobustScaler com dados simulados."""
    print("--- 1. TREINAMENTO DO MODELO (DADOS SIMULADOS) ---")

    n = 1000
    baixo = pd.DataFrame({
        'D_min_km': np.random.uniform(2.0, 15.0, int(0.9 * n)),
        'V_rel_kms': np.random.uniform(5.0, 14.0, int(0.9 * n)),
        'T_min_min': np.random.uniform(-1440, 1440, int(0.9 * n)),
        'RISCO_ALTO': 0
    })
    alto = pd.DataFrame({
        'D_min_km': np.random.uniform(0.05, 0.5, int(0.1 * n)),
        'V_rel_kms': np.random.uniform(12.0, 15.0, int(0.1 * n)),
        'T_min_min': np.random.uniform(-360, 360, int(0.1 * n)),
        'RISCO_ALTO': 1
    })
    df_simulado = pd.concat([baixo, alto]).sample(frac=1).reset_index(drop=True)

    X = df_simulado[['D_min_km', 'V_rel_kms', 'T_min_min']]
    y = df_simulado['RISCO_ALTO']

    X_train_raw, _, y_train, _ = train_test_split(
        X, y, test_size=0.3, random_state=RANDOM_STATE, stratify=y
    )
    scaler = RobustScaler().fit(X_train_raw)
    X_train_scaled = scaler.transform(X_train_raw)

    oversample = SMOTE(random_state=RANDOM_STATE)
    X_train_balanced, y_train_balanced = oversample.fit_resample(X_train_scaled, y_train)

    modelo_base = svm.SVC(kernel='rbf', C=100, gamma=1, probability=True, random_state=RANDOM_STATE)
    modelo_base.fit(X_train_balanced, y_train_balanced)

    print("Modelo SVM e RobustScaler treinados com sucesso.")
    return modelo_base, scaler

# --- 2. MODO OFFLINE: PREVISÃO COM CSV (MITIGAÇÃO DE FN) ---

def modo_offline_csv(modelo, scaler):

    """Executa a previsão de risco em lote em dados de um CSV."""

    # Loop para permitir o processamento repetido de arquivos
    while True:
        caminho = input("\nCaminho do arquivo CSV para PREVISÃO (ou 'sair'): ")

        if caminho.lower() == 'sair':
            break

        try:
            # NOTA: Ajustar 'format' se o CSV for diferente de DD/MM/AAAA HH:MM
            df_raw = pd.read_csv(caminho, sep=';')
            print(f"Arquivo '{caminho}' carregado. {len(df_raw)} eventos para análise.")
        except FileNotFoundError:
            print("ERRO: Arquivo não encontrado. Tente novamente.")
            continue
        except Exception as e:
            print(f"ERRO ao carregar o arquivo: {e}")
            continue

        dados_previsao = []

        for index, row in df_raw.iterrows():
            try:
                # Extração e Cálculo de Features (simplificado)
                l1_a, l2_a = row['TLE_LINE1_A'], row['TLE_LINE2_A']
                l1_b, l2_b = row['TLE_LINE1_B'], row['TLE_LINE2_B']
                tca_dt = pd.to_datetime(row['TCA_UTC'], format='%d/%m/%Y %H:%M', errors='coerce').replace(tzinfo=utc)
                d_min, v_rel, t_min, _ = calcular_melhor_aproximacao(l1_a, l2_a, l1_b, l2_b, tca_dt)

                if np.isnan(d_min): continue

                features_raw = np.array([[d_min, v_rel, t_min]])
                features_scaled = scaler.transform(features_raw)

                # --- LÓGICA DE CLASSIFICAÇÃO COM CORREÇÃO DE LIMIAR (FN MITIGADO) ---
                prob_alto = modelo.predict_proba(features_scaled)[0, 1]
                risco_alerta = 1 if prob_alto > LIMIAR_CONSERVADOR else 0

                dados_previsao.append({
                    'D_min_km': d_min,
                    'V_rel_kms': v_rel,
                    'T_min_min': t_min,
                    'RISCO_ALTO_Previsto': risco_alerta,
                    'Prob_Alto_Risco': prob_alto,
                    'RISCO_ALTO_Historico': row.get('RISCO_ALTO', np.nan)
                })

            except KeyError:
                print("\nERRO: Verifique se o CSV contém as colunas TLE_LINE1_A/B, TCA_UTC e RISCO_ALTO.")
                break
            except Exception:
                continue

        df_previsao = pd.DataFrame(dados_previsao)

        if not df_previsao.empty:
            print("\n--- RESULTADO DA PREVISÃO EM LOTE ---")
            print(df_previsao.to_markdown(index=False, floatfmt=".2f"))

            # --- NOVO MENU DE REPETIÇÃO ---
            while True:
                escolha_loop = input("\nO que deseja fazer? (1: Novo Arquivo | 2: Encerrar): ").strip()
                if escolha_loop == '1':
                    print("-" * 30)
                    break # Sai do loop interno e volta ao início do loop 'while True' externo
                elif escolha_loop == '2':
                    return # Sai da função, encerrando o programa
                else:
                    print("Opção inválida.")
        else:
            print("\nNenhum evento válido processado.")
            break # Evita loop infinito em caso de erro sem resultados

# --- FUNÇÃO PRINCIPAL (Controle de Fluxo) ---

if __name__ == '__main__':

    print("\n=======================================================")
    print("SISTEMA DE PREVENÇÃO DE CONJUNÇÃO (Co-Lead)")
    print("=======================================================")

    modelo, scaler = treinar_modelo_inicial()

    if modelo is None:
        sys.exit(1)

    print("\n--- INICIANDO MODO OFFLINE ---")
    modo_offline_csv(modelo, scaler)
    print("\nPrograma encerrado.")